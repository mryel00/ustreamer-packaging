name: Create Release

on:
  workflow_dispatch:

jobs:
  trigger-build:
    runs-on: ubuntu-24.04
    outputs:
      run-id: ${{ steps.trigger.outputs.run-id }}
    
    steps:
    - name: Trigger build workflow
      id: trigger
      uses: actions/github-script@v7
      with:
        script: |
          const response = await github.rest.actions.createWorkflowDispatch({
            owner: context.repo.owner,
            repo: context.repo.repo,
            workflow_id: 'build-deb.yml',
            ref: context.ref
          });
          
          // Wait a bit for the workflow to start
          await new Promise(resolve => setTimeout(resolve, 5000));
          
          // Get the workflow run
          const runs = await github.rest.actions.listWorkflowRuns({
            owner: context.repo.owner,
            repo: context.repo.repo,
            workflow_id: 'build-deb.yml',
            event: 'workflow_dispatch',
            per_page: 1
          });
          
          const runId = runs.data.workflow_runs[0].id;
          console.log(`Triggered workflow run ID: ${runId}`);
          core.setOutput('run-id', runId);
          
          return runId;
  
  wait-for-build:
    runs-on: ubuntu-24.04
    needs: trigger-build
    
    steps:
    - name: Wait for build workflow to complete
      uses: actions/github-script@v7
      with:
        script: |
          const runId = ${{ needs.trigger-build.outputs.run-id }};
          console.log(`Waiting for workflow run ${runId} to complete...`);
          
          let completed = false;
          let conclusion = null;
          
          while (!completed) {
            const run = await github.rest.actions.getWorkflowRun({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: runId
            });
            
            console.log(`Status: ${run.data.status}, Conclusion: ${run.data.conclusion}`);
            
            if (run.data.status === 'completed') {
              completed = true;
              conclusion = run.data.conclusion;
            } else {
              // Wait 30 seconds before checking again
              await new Promise(resolve => setTimeout(resolve, 30000));
            }
          }
          
          if (conclusion !== 'success') {
            core.setFailed(`Build workflow failed with conclusion: ${conclusion}`);
          }
          
          console.log('Build workflow completed successfully!');
  
  create-release:
    runs-on: ubuntu-24.04
    needs: [trigger-build, wait-for-build]
    permissions:
      contents: write
    
    steps:
    - name: Checkout packaging repository
      uses: actions/checkout@v4.2.2
    
    - name: Get latest ustreamer tag
      id: get_tag
      run: |
        LATEST_TAG=$(git ls-remote --tags --sort=v:refname https://github.com/pikvm/ustreamer.git | grep -v '\^{}' | tail -1 | sed 's/.*refs\/tags\///')
        echo "tag=$LATEST_TAG" >> $GITHUB_OUTPUT
        echo "Latest ustreamer tag: $LATEST_TAG"
        
        # Extract version without 'v' prefix
        VERSION=$(echo "$LATEST_TAG" | sed 's/^v//')
        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "Version: $VERSION"
    
    - name: Download all artifacts from build workflow
      uses: actions/download-artifact@v4
      with:
        path: artifacts
        pattern: mainsail-ustreamer-*
        merge-multiple: false
        run-id: ${{ needs.trigger-build.outputs.run-id }}
        github-token: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Organize artifacts
      run: |
        mkdir -p release-files
        find artifacts -name "*.deb" -exec cp {} release-files/ \;
        ls -lh release-files/
    
    - name: Generate release notes
      id: release_notes
      run: |
        cat > release-notes.md << 'EOF'
        # mainsail-ustreamer ${{ steps.get_tag.outputs.version }}
        
        Debian packages for µStreamer ${{ steps.get_tag.outputs.tag }} (pikvm/ustreamer).
        
        ## Installation
        
        Download the appropriate `.deb` file for your system and install with:
        ```bash
        sudo dpkg -i mainsail-ustreamer_${{ steps.get_tag.outputs.version }}-1_<arch>.deb
        sudo apt-get install -f  # Install dependencies if needed
        ```
        
        ## Packages
        
        This release includes packages for:
        - **Debian Bullseye (11)**: amd64, armhf, arm64
        - **Debian Bookworm (12)**: amd64, armhf, arm64
        - **Debian Trixie (13)**: amd64, armhf, arm64
        
        ## Features
        
        - µStreamer MJPEG-HTTP streaming server
        - ustreamer-dump utility
        - GPIO and systemd support enabled
        - Compatible with upstream ustreamer package
        
        ## Upstream
        
        Based on [pikvm/ustreamer ${{ steps.get_tag.outputs.tag }}](https://github.com/pikvm/ustreamer/releases/tag/${{ steps.get_tag.outputs.tag }})
        EOF
        cat release-notes.md
    
    - name: Check if release exists
      id: check_release
      run: |
        if gh release view "${{ steps.get_tag.outputs.tag }}" &>/dev/null; then
          echo "exists=true" >> $GITHUB_OUTPUT
          echo "Release ${{ steps.get_tag.outputs.tag }} already exists"
        else
          echo "exists=false" >> $GITHUB_OUTPUT
          echo "Release ${{ steps.get_tag.outputs.tag }} does not exist"
        fi
      env:
        GH_TOKEN: ${{ github.token }}
    
    - name: Delete existing release if it exists
      if: steps.check_release.outputs.exists == 'true'
      run: |
        gh release delete "${{ steps.get_tag.outputs.tag }}" --yes --cleanup-tag
        echo "Deleted existing release ${{ steps.get_tag.outputs.tag }}"
      env:
        GH_TOKEN: ${{ github.token }}
    
    - name: Create GitHub Release
      uses: softprops/action-gh-release@v2
      with:
        tag_name: ${{ steps.get_tag.outputs.tag }}
        name: mainsail-ustreamer ${{ steps.get_tag.outputs.version }}
        body_path: release-notes.md
        files: release-files/*.deb
        draft: false
        prerelease: false
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
